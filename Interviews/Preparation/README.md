## Resources:

- [Design Patterns for Humans](https://github.com/kamranahmedse/design-patterns-for-humans?fbclid=IwAR2Fhim50O1qHk7RzgihV28-ytI4yr0hOExLnRXgVgC-IKbmrBiA2pt1t64)
- [**Head-FirstDesign-Patterns implemented in Java**](https://github.com/bethrobson/Head-First-Design-Patterns)
- [Design-Patterns-In-Python](**https://github.com/Sean-Bradley/Design-Patterns-In-Python)
- Checkout Buyya - http://www.buyya.com/254/ - Univ of Melbourne - Url Not responding  
- https://refactoring.guru/design-patterns
- Interfaces in Python - https://realpython.com/python-interface/
- https://www.python-course.eu/python3_metaclasses.php
- Derek Banas: https://www.newthinktank.com/2012/10/iterator-design-pattern-tutorial/

TO READ:
- https://stackoverflow.com/questions/6966772/using-the-call-method-of-a-metaclass-instead-of-new
- https://stackoverflow.com/questions/392160/what-are-some-concrete-use-cases-for-metaclasses
- https://web.archive.org/web/20080206005253
- Have a look at [https://www.fullstack.cafe/Design%20Patterns](https://www.fullstack.cafe/Design Patterns)

# Top OO Design Questions:

From https://hackernoon.com/the-top-10-object-oriented-design-interview-questions-developers-should-know-c7fc2e13ce39:

-   [x] Design an elevator system 
-   [ ] [Design a Library Management System](https://www.educative.io/courses/grokking-the-object-oriented-design-interview/RMlM3NgjAyR)
-   [ ] [Design a Parking Lot](https://www.educative.io/courses/grokking-the-object-oriented-design-interview/gxM3gRxmr8Z)
-   [ ] Design a chat server
-   [ ] [Design Amazon - Online Shopping System](https://www.educative.io/courses/grokking-the-object-oriented-design-interview/Bn8PMllro6Q)
-   [ ] [Design Stack Overflow](https://www.educative.io/courses/grokking-the-object-oriented-design-interview/m2YWoEq06AR)
-   [ ] [Design a Movie Ticket Booking System](https://www.educative.io/courses/grokking-the-object-oriented-design-interview/gxkvNgMqDk3)
-   [ ] [Design an ATM](https://www.educative.io/courses/grokking-the-object-oriented-design-interview/m22LWKgQ4Wr)
-   [ ] [Design an Airline Management System](https://www.educative.io/courses/grokking-the-object-oriented-design-interview/RMjqP6Vw98R)
-   [ ] [Design Blackjack and a Deck of Cards](https://www.educative.io/courses/grokking-the-object-oriented-design-interview/YQ5gm2APRnp)
-   [ ] [Design a Hotel Management System](https://www.educative.io/courses/grokking-the-object-oriented-design-interview/39Ek39vZBy9)
-   [ ] [Design a Restaurant Management system](https://www.educative.io/courses/grokking-the-object-oriented-design-interview/xV8p1GA6K0r)
-   [ ] [Design Chess](https://www.educative.io/courses/grokking-the-object-oriented-design-interview/JP7BXYkj3DK)
-   [ ] [Design an Online Stock Brokerage System](https://www.educative.io/courses/grokking-the-object-oriented-design-interview/RM8ol3m2o3w)
-   [ ] [Design a Car Rental System](https://www.educative.io/courses/grokking-the-object-oriented-design-interview/B8QoxDl6YON)
-   [ ] [Design LinkedIn](https://www.educative.io/courses/grokking-the-object-oriented-design-interview/gxMOMDVKlBk)
-   [ ] [Design Cricinfo](https://www.educative.io/courses/grokking-the-object-oriented-design-interview/YQ7lDLlNl5A)
-   [ ] [Design Facebook - a social network](https://www.educative.io/courses/grokking-the-object-oriented-design-interview/7n94JNyPOMw)




<u>From https://en.wikipedia.org/wiki/Design_Patterns:</u>

### Creational[[edit](https://en.wikipedia.org/w/index.php?title=Design_Patterns&action=edit&section=12)]

Main article: [Creational pattern](https://en.wikipedia.org/wiki/Creational_pattern)

[Creational patterns](https://en.wikipedia.org/wiki/Creational_pattern) are ones that create objects, rather than having to instantiate objects directly. This gives the program more flexibility in deciding which objects need to be created for a given case⁄

-   [x] [Abstract factory](https://en.wikipedia.org/wiki/Abstract_factory_pattern) groups object factories that have a common theme.
-   [x] [Builder](https://en.wikipedia.org/wiki/Builder_pattern) constructs complex objects by separating construction and representation.
-   [x] [Factory method](https://en.wikipedia.org/wiki/Factory_method_pattern) creates objects without specifying the exact class to create.
-   [x] [Prototype](https://en.wikipedia.org/wiki/Prototype_pattern) creates objects by cloning an existing object.
-   [x] [Singleton](https://en.wikipedia.org/wiki/Singleton_pattern) restricts object creation for a class to only one instance.

### Structural[[edit](https://en.wikipedia.org/w/index.php?title=Design_Patterns&action=edit&section=13)]

These concern class and object composition. They use inheritance to compose interfaces and define ways to compose objects to obtain new functionality.

-   [x] [Adapter](https://en.wikipedia.org/wiki/Adapter_pattern) allows classes with incompatible interfaces to work together by wrapping its own interface around that of an already existing class.
-   [x] [Bridge](https://en.wikipedia.org/wiki/Bridge_pattern) decouples an abstraction from its implementation so that the two can vary independently.
-   [x] [Composite](https://en.wikipedia.org/wiki/Composite_pattern) composes zero-or-more similar objects so that they can be manipulated as one object.
-   [ ] [Decorator](https://en.wikipedia.org/wiki/Decorator_pattern) dynamically adds/overrides behaviour in an existing method of an object.
-   [x] [Facade](https://en.wikipedia.org/wiki/Facade_pattern) provides a simplified interface to a large body of code.
-   [x] [Flyweight](https://en.wikipedia.org/wiki/Flyweight_pattern) reduces the cost of creating and manipulating a large number of similar objects.
-   [x] [Proxy](https://en.wikipedia.org/wiki/Proxy_pattern) provides a placeholder for another object to control access, reduce cost, and reduce complexity.

### Behavioral[[edit](https://en.wikipedia.org/w/index.php?title=Design_Patterns&action=edit&section=14)]

Most of these design patterns are specifically concerned with communication between **objects**.

-   [x] [Chain of responsibility](https://en.wikipedia.org/wiki/Chain-of-responsibility_pattern) delegates commands to a chain of processing objects.
-   [x] [Command](https://en.wikipedia.org/wiki/Command_pattern) creates objects which encapsulate actions and parameters.
-   [x] [Interpreter](https://en.wikipedia.org/wiki/Interpreter_pattern) implements a specialized language.
-   [x] [Iterator](https://en.wikipedia.org/wiki/Iterator_pattern) accesses the elements of an object sequentially without exposing its underlying representation.
-   [ ] [Mediator](https://en.wikipedia.org/wiki/Mediator_pattern) allows [loose coupling](https://en.wikipedia.org/wiki/Loose_coupling) between classes by being the only class that has detailed knowledge of their methods.
-   [ ] [Memento](https://en.wikipedia.org/wiki/Memento_pattern) provides the ability to restore an object to its previous state (undo).
-   [x] [Observer](https://en.wikipedia.org/wiki/Observer_pattern) is a publish/subscribe pattern which allows a number of observer objects to see an event.
-   [ ] [State](https://en.wikipedia.org/wiki/State_pattern) allows an object to alter its behavior when its internal state changes.
-   [x] [Strategy](https://en.wikipedia.org/wiki/Strategy_pattern) allows one of a family of algorithms to be selected on-the-fly at runtime.
-   [ ] [Template method](https://en.wikipedia.org/wiki/Template_method_pattern) defines the skeleton of an algorithm as an abstract class, allowing its subclasses to provide concrete behavior.
-   [ ] [Visitor](https://en.wikipedia.org/wiki/Visitor_pattern) separates an algorithm from an object structure by moving the hierarchy of methods into one object.
------

## Mixins vs Abstract Classes vs Interfaces

From https://stackoverflow.com/a/59752820/6463555:

  1. Abstract Class

     - Class that needs to contain one or more abstract methods

     - Abstract Class can contain state (instance variables) and non-abstract methods

  2. Interface

     - Interface contains abstract methods only (no non-abstract methods and no internal state)
  3. MixIns

     - MixIns (like Interfaces) do not contain internal state (instance variables)  
     - MixIns contain one or more non-abstract methods (they can contain non-abstract methods unlike interfaces)  
     - In e.g. Python these are just conventions, because all of the above are defined as classes. However, the common feature of both Abstract Classes, Interfaces and MixIns is that they should not exist on their own, i.e. should not be instantiated.

## Mixins in Python

Basically read **https://stackoverflow.com/questions/533631/what-is-a-mixin-and-why-are-they-useful**.  

Mixins in Python are similar to **Curiously Recurring Template Pattern (CRTP)** in C++.

From https://stackoverflow.com/a/17491186/6463555: 

> My understanding of the conventions that govern something you would call a Mixin are that a Mixin:
>
> - adds methods but not instance variables (class constants are OK)
> - only inherits from object (in Python)

**From https://stackoverflow.com/a/36222493/6463555:**

> In the context of Python especially, a mixin is a parent class that provides functionality to 
> subclasses but is not intended to be instantiated itself.

**Example of Multiple Inheritance**

This example, from the documentation, is an OrderedCounter:

```
class OrderedCounter(Counter, OrderedDict):
     'Counter that remembers the order elements are first encountered'

     def __repr__(self):
         return '%s(%r)' % (self.__class__.__name__, OrderedDict(self))

     def __reduce__(self):
         return self.__class__, (OrderedDict(self),)
```

> It subclasses both the Counter and the OrderedDict from the collections module.

> Both Counter and OrderedDict are intended to be instantiated and used on their own. However, by subclassing them both, we can have a counter that is ordered and reuses the code in each object.

> This is a powerful way to reuse code, but it can also be problematic. If it turns out there's a bug in one of the objects, fixing it without care could create a bug in the subclass.

**Example of a Mixin**  

> Unlike the example above, a mixin is not intended to be used on its own. It provides new or different functionality.
>
> For example, the standard library has a couple of mixins in the socketserver library.
>
> Forking and threading versions of each type of server can be created using these mix-in classes. For instance, ThreadingUDPServer is created as follows:

```python
class ThreadingUDPServer(ThreadingMixIn, UDPServer):
    pass
```

> The mix-in class comes first, since it overrides a method defined in UDPServer. Setting the various attributes also changes the behavior of the underlying server mechanism.
>
> In this case, the mixin methods override the methods in the UDPServer object definition to allow for concurrency.

## Metaclasses

Must read: https://stackoverflow.com/a/6581949/6463555  

> `type` is the metaclass Python uses to create all classes behind the scenes.

> You can call it a 'class factory' if you wish.

> The main purpose of a metaclass is to change the class automatically, when it's created.
> 
> You usually do this for APIs, where you want to create classes matching the current context.
>   
> Imagine a stupid example, where you decide that all classes in your module should have their attributes written in uppercase. There are several ways to do this, but one way is to set __metaclass__ at the module level.
>   
> This way, all classes of this module will be created using this metaclass, and we just have to tell the metaclass to turn all attributes to uppercase.  
>
> you can have metaclasses, inheriting from metaclasses

Why would you use metaclasses classes instead of functions?
-  Subclasses of a class will be instances of its metaclass if you specified a metaclass-class, but not with a metaclass-function.
- You can hook on __new__, __init__ and __call__. Which will allow you to do different stuff. Even if usually you can do it all in __new__, some people are just more comfortable using __init__.
-  Other reasons in the answer.

**Use of metaclasses in DJango ORM:**  
The main use case for a metaclass is creating an API. A typical example of this is the Django ORM. It allows you to define something like this:

```python
class Person(models.Model):
    name = models.CharField(max_length=30)
    age = models.IntegerField()
But if you do this:

person = Person(name='bob', age='35')
print(person.age)
```
It won't return an IntegerField object. It will return an int, and can even take it directly from the database.

This is possible because models.Model defines \_\_metaclass__ and it uses some magic that will turn the Person you just defined with simple statements into a complex hook to a database field.

Django makes something complex look simple by exposing a simple API and using metaclasses, recreating code from this API to do the real job behind the scenes.

------

From https://www.python-course.eu/python3_metaclasses.php

A metaclass is a class whose instances are classes.

Uses:
- logging and profiling
- interface checking
- registering classes at creation time
- automatically adding new methods
- automatic property creation
- proxies
- automatic resource locking/synchronization.

### Singleton using metaclasses

The singleton pattern is a design pattern that restricts the instantiation of a class to one object. It is used in cases where exactly one object is needed. The conceptcan be generalized to restrict the instantiation to a certain or fixed number of objects. The term stems from mathematics, where a singleton, - also called a unit set -, is used for sets with exactly one element.

```python
class Singleton(type):
    _instances = {}
    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)
        return cls._instances[cls]
        
class SingletonClass(metaclass=Singleton):
    pass

class RegularClass():
    pass

x = SingletonClass()
y = SingletonClass()
print(x == y) # True

x = RegularClass()
y = RegularClass()
print(x == y) # False
```
### Singleton classes using inheriting

```python
class Singleton(object):
    _instance = None
    def __new__(cls, *args, **kwargs):
        if not cls._instance:
            cls._instance = object.__new__(cls, *args, **kwargs)
        return cls._instance

class SingletonClass(Singleton):
    pass

class RegularClass():
    pass

x = SingletonClass()
y = SingletonClass()
print(x == y) # True


x = RegularClass()
y = RegularClass()
print(x == y) # False
```
### Profiling class methods using metaclasses

Counting number of call of all the functions/methods of a class.

```python
class FuncCallCounter(type):
    """ A Metaclass which decorates all the methods of the 
        subclass using call_counter as the decorator
    """
    @staticmethod
    def call_counter(func):
        """ Decorator for counting the number of function 
            or method calls to the function or method func
        """
        def helper(*args, **kwargs):
            helper.calls += 1
            return func(*args, **kwargs)
        helper.calls = 0
        helper.__name__= func.__name__
    
        return helper
    
    def __new__(cls, clsname, superclasses, attributedict):
        """ Every method gets decorated with the decorator call_counter,
            which will do the actual call counting
        """
        for attr in attributedict:
            if callable(attributedict[attr]) and not attr.startswith("__"):
                attributedict[attr] = cls.call_counter(attributedict[attr])
        
        return type.__new__(cls, clsname, superclasses, attributedict)
    
class A(metaclass=FuncCallCounter):
    
    def foo(self):
        pass
    
    def bar(self):
        pass

if __name__ == "__main__":
    x = A()
    print(x.foo.calls, x.bar.calls)
    x.foo()
    print(x.foo.calls, x.bar.calls)
    x.foo()
    x.bar()
    print(x.foo.calls, x.bar.calls)
```
OUTPUT:

```python
0 0
1 0
2 1
```

## Abstract Classes

From https://www.python-course.eu/python3_abstract_classes.php:

>   Abstract classes are classes that contain one or more abstract methods. An abstract method is a 
>   method that is declared, but contains no implementation. Abstract classes cannot be instantiated, 
>   and require subclasses to provide implementations for the abstract methods.

>   A class that is derived from an abstract class cannot be instantiated unless all of its abstract methods are overridden.

A class which inherits from an abstract class and implements all the abstractmethods is called a 
**concrete class**.

From https://stackoverflow.com/a/18030001/6463555:
> If a subclass of an abstract class overrides, i.e. provides an implementation of every abstract method in its superclass, the subclass is called a concrete class and objects of the subclass can be created
> If a subclass of an abstract class does not override (implement) all of the abstract methods it inherits, that subclass itself is also abstract and must be declared as such

```python
from abc import ABC, abstractmethod
 
class AbstractClassExample(ABC):
 
    def __init__(self, value):
        self.value = value
        super().__init__()
    
    @abstractmethod
    def do_something(self):
        pass
        
class DoAdd42(AbstractClassExample):

    def do_something(self):
        return self.value + 42
    
class DoMul42(AbstractClassExample):
   
    def do_something(self):
        return self.value * 42
    
x = DoAdd42(10)
y = DoMul42(10)

print(x.do_something())
print(y.do_something())
```
```python
52
420
```

## Interfaces in Python

Checkout **Interfaces in Other Languages** section in  https://realpython.com/python-interface.

- Python uses abstract base classes to implement interfaces.
- C++ uses **virtual** keyword before class methods to define abstract base classes.
- Java has **interface** keywork to define interfaces. **Concrete classes** use **implements** keyword to implement the interfaces.

## Factory Pattern

- https://medium.com/@hardikpatel_6314/design-patterns-in-python-factory-c728b88603eb
- From https://refactoring.guru/design-patterns/factory-method
- https://www.geeksforgeeks.org/design-patterns-set-2-factory-method/?ref=lbp

## Abstract Factory Pattern

-
https://www.geeksforgeeks.org/abstract-factory-pattern/  
https://refactoring.guru/design-patterns/abstract-factory

### Factory vs Abstract factory

- https://dzone.com/articles/factory-method-vs-abstract

- When we need another layer of abstraction.

### E.G. 1: abstract_factory.py

From https://refactoring.guru/design-patterns/abstract-factory:

> Imagine that you’re creating a furniture shop simulator. Your code consists of classes that represent:
> - A family of related products, say: Chair + Sofa + CoffeeTable.
> - Several variants of this family. For example, products Chair + Sofa + CoffeeTable are available in these variants: Modern, Victorian, ArtDeco.

### E.G. 2: abstract_factory2.py - Seems to be a better design than abstract_factory.py

From https://www.geeksforgeeks.org/abstract-factory-pattern/:

> Let’s take an example, Suppose we want to build a global car factory. If it was factory design pattern, then it was suitable for a single location. But for this pattern, we need multiple locations and some critical design changes.
> 
> We need car factories in each location like IndiaCarFactory, USACarFactory and DefaultCarFactory. Now, our application should be smart enough to identify the location where it is being used, so we should be able to use appropriate car
factory without even knowing which car factory implementation will be used internally. This also saves us from someone calling wrong factory for a particular location.
> 
> Here we need another layer of abstraction which will identify the location and internally use correct car factory implementation without even giving a single hint to user. This is exactly the problem, which abstract factory pattern is used to solve.
Somewhat the above example is also based on How the Cabs like uber and ola functions on the large scale.

### How to implement abstract factory 

From https://refactoring.guru/design-patterns/abstract-factory:

1. Map out a matrix of distinct product types versus variants of these products.

1. Declare abstract product interfaces for all product types. Then make all concrete product classes implement these interfaces.

1. Declare the abstract factory interface with a set of creation methods for all abstract products.

1. Implement a set of concrete factory classes, one for each product variant.

1. Create factory initialization code somewhere in the app. It should instantiate one of the concrete factory classes, depending on the application configuration or the current environment. Pass this factory object to all classes that construct products.

1. Scan through the code and find all direct calls to product constructors. Replace them with calls to the appropriate creation method on the factory object.

## Observer Pattern 

**see observer.py**  

From https://www.geeksforgeeks.org/observer-pattern-set-1-introduction/?ref=lbp:
> The Observer Pattern defines a one to many dependency between objects so that one object changes state, all of its dependents are notified and updated automatically.

Take care of the [**Lapsed listener problem**](https://en.wikipedia.org/wiki/Lapsed_listener_problem) by using **weak references**.

**Real Life Uses:**

- It is heavily used in GUI toolkits and event listener. In java the button(subject) and onClickListener(observer) are modelled with observer pattern.
- Social media, RSS feeds, email subscription in which you have the option to follow or subscribe and you receive latest notification.
- All users of an app on play store gets notified if there is an update.

**Good read: https://refactoring.guru/design-patterns/observer**

## Singleton

Example use cases:

- Logger
- DB connection

**Naïve** Singleton in C++: https://refactoring.guru/design-patterns/singleton/cpp/example  
**Thread-safe** Singleton in C++: https://refactoring.guru/design-patterns/singleton/cpp/example#example-1

**Thread-safe** Singleton in Python: https://refactoring.guru/design-patterns/singleton/python/example#example-1--main-py

## Strategy Pattern

From https://www.geeksforgeeks.org/strategy-pattern-set-1/

> Suppose we are building a game “Street Fighter”. For simplicity assume that a character may have
 four moves that is kick, punch, roll and jump. Every character has kick and punch moves, but roll
  and jump are optional. How would you model your classes?

**Inheritence: A Base class containing all moves?**  
We can define a Base **Figher** class with default implementation of kick, punch, roll and jump
 methods and override them in subclasses.  

- Not all players need all the moves. A player not needing jump will inherit jump. It can make
those moves *noop* but we would have to do it in **all** the sub classes. This is difficult to maintain. 
- All the player classes will need to override the methods for special moves.

**Interface for each move - {Kick,Punch,Jump,Roll}Interface?**  

- Each player can implement the interface for whatever move they require. E.g.,
    ```java
    interface Kick;
    interface Punch;
    interface Jump;
    interface Roll;
    
    class Chunli implements Kick, Punch, Jump, Roll; // Note: We can implement multiple interfaces in Java
    ```

- The main issue here is **code** reuse. Since there is no default implementation, each player
  who wants a move, say **JumpBehavior**, will need to repeat the code.

**Default Base class for each move?**  

We can have a default Base class instead of interfaces for each move. Each concrete class can
  then inherit the required classes.

```java
class DefaultKick;
class DefaultPunch;
class DefaultJump;
class DefaultRoll;

class Ryu(DefaultKick, DefaultPunch, DefaultJump)
class Ryu(DefaultKick, DefaultRoll)
```

However, **multiple inheritance** that is not supported in many languages due to many problems 
associated with it.

**Dynamic composition of each concrete move for creating a player** #Strategy Pattern
https://www.geeksforgeeks.org/strategy-pattern-set-2

1. Identify the family of algorithms which vary: we need multiple versions of kick, jump, etc. 
   Define interfaces for each family and implement concrete classes. 
```python
interface Kick;

TornadoKick implements Kick;
FlyingKick implements Kick;
```
1. In the context class, add a field for storing a reference to a strategy object. Provide a setter
   for replacing values of that field. The context should work with the strategy object only via the
   strategy interface. The context may define an interface which lets the strategy access its data.
```python
from abc import ABC, abstractmethod
class Fighter(ABC):
    def __init__(self, kick_behavior=None):
        self.kick_behavior = kick_behavior
    
    def kick(self):
        self.kick_behavior()
    
    @abstractmethod
    def display(self):
        pass

class Ryu(Fighter):
    def display(self):
        print(self.__class__.__name__)

ryu = Ryu(jump_behavior=TornadoKick)
ryu.kick() # executes TornadoKick

# Change behavior dynamically (algorithms are interchangeable)
ryu.kick_behavior = FlyingKick
ryu.kick() # executes FlyingKick
```
TODO: Implement this in Python
Ref: https://refactoring.guru/design-patterns/strategy

## Iterator Pattern

 https://www.youtube.com/watch?v=VKIzUuMdmag&list=PLF206E906175C7E07&index=18&t=0s

## Builder Pattern

Suppose we want to create two types of objects: **AppleIPhone** and **SamsungNote**. Both of these phones accept a large number of properties like cpu, ram, screen_size, battery, price, etc. We can create these phones in three different ways:

1. Use a long constructor:

   ```4python
   def AppleIphone:
     def __init__(cpu, ram, screen_size, battery, price):
       <SNIP>
   
   def SamsungNote:
     def __init__(cpu, ram, screen_size, battery, price):
       <SNIP>
   
   # Instantiation in client code
   my_iphone = AppleIPhone("qualcomm", "4GB", "5inch", "4000mMaH", "INR10K")
   ```

   Con:

   - **Possibility of switching arguments of same type**: This becomes clumsy in languages like Java and C++ which don't support passing keyword arguments to the constructor as the order is not apparent in such cases.

   - **Need to pass ALL parameters**:  In languages like C++/Java which don't have keyword arguments: We need to pass all the parameters. **Build Pattern is used to simulate keyword arguments in Java**. 

     From https://stackoverflow.com/a/1988035/6463555:

     >   The best Java idiom I've seem for simulating keyword arguments in constructors is the Builder pattern, described in [Effective Java 2nd Edition](http://java.sun.com/docs/books/effective/).
>
     >   The basic idea is to have a Builder class that has setters (but usually not getters) for the different constructor parameters. There's also a `build()` method. The Builder class is often a (static) nested class of the class that it's used to build. The outer class's constructor is often private.
>
     >   The end result looks something like:
>
     >   ```java
     >   public class Foo {
     >     public static class Builder {
     >       public Foo build() {
     >         return new Foo(this);
     >       }
     >   
     >       public Builder setSize(int size) {
     >         this.size = size;
     >         return this;
     >       }
     >   
     >       public Builder setColor(Color color) {
     >         this.color = color;
     >         return this;
     >       }
     >   
     >       public Builder setName(String name) {
     >         this.name = name;
     >         return this;
     >       }
     >   
     >       // you can set defaults for these here
     >       private int size;
     >       private Color color;
     >       private String name;
     >     }
     >   
     >     public static Builder builder() {
     >         return new Builder();
     >     }
     >   
     >     private Foo(Builder builder) {
     >       size = builder.size;
     >       color = builder.color;
     >       name = builder.name;
     >     }
     >   
     >     private final int size;
     >     private final Color color;
     >     private final String name;
     >   
     >     // The rest of Foo goes here...
     >   }
     >   ```
>
     >   To create an instance of Foo you then write something like:
>
     >   ```java
     >   Foo foo = Foo.builder()
     >       .setColor(red)
     >       .setName("Fred")
     >       .setSize(42)
     >       .build();
     >   ```
>
     >   The main caveats are:
>
     >   1. Setting up the pattern is pretty verbose (as you can see). Probably not worth it except for classes you plan on instantiating in many places.
     >   2. There's no compile-time checking that all of the parameters have been specified exactly once. You can add runtime checks, or you can use this only for optional parameters and make required parameters normal parameters to either Foo or the Builder's constructor. (People generally don't worry about the case where the same parameter is being set multiple times.)
>
     >   You may also want to check out [this blog post](http://rwhansen.blogspot.com/2007/07/theres-builder-pattern-that-joshua.html) (not by me).

   - The object phone can't be used unless **all** of its parts are instantiated. I.e., we can't use it unless we pass its `price`. 




