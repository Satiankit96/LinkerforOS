## Resources:

- [Design Patterns for Humans](https://github.com/kamranahmedse/design-patterns-for-humans?fbclid=IwAR2Fhim50O1qHk7RzgihV28-ytI4yr0hOExLnRXgVgC-IKbmrBiA2pt1t64)
- [**Head-FirstDesign-Patterns implemented in Java**](https://github.com/bethrobson/Head-First-Design-Patterns)
- [Design-Patterns-In-Python](**https://github.com/Sean-Bradley/Design-Patterns-In-Python)
- Checkout Buyya - http://www.buyya.com/254/ - Univ of Melbourne - Url Not responding  
- https://refactoring.guru/design-patterns
- Interfaces in Python - https://realpython.com/python-interface/
- https://www.python-course.eu/python3_metaclasses.php
- Derek Banas: https://www.newthinktank.com/2012/10/iterator-design-pattern-tutorial/

TO READ:
- https://stackoverflow.com/questions/6966772/using-the-call-method-of-a-metaclass-instead-of-new
- https://stackoverflow.com/questions/392160/what-are-some-concrete-use-cases-for-metaclasses
- https://web.archive.org/web/20080206005253
- Have a look at [https://www.fullstack.cafe/Design%20Patterns](https://www.fullstack.cafe/Design Patterns)

# Top OO Design Questions:

From https://hackernoon.com/the-top-10-object-oriented-design-interview-questions-developers-should-know-c7fc2e13ce39:

-   [x] Design an elevator system 
-   [ ] [Design a Library Management System](https://www.educative.io/courses/grokking-the-object-oriented-design-interview/RMlM3NgjAyR)
-   [ ] [Design a Parking Lot](https://www.educative.io/courses/grokking-the-object-oriented-design-interview/gxM3gRxmr8Z)
-   [ ] Design a chat server
-   [ ] [Design Amazon - Online Shopping System](https://www.educative.io/courses/grokking-the-object-oriented-design-interview/Bn8PMllro6Q)
-   [ ] [Design Stack Overflow](https://www.educative.io/courses/grokking-the-object-oriented-design-interview/m2YWoEq06AR)
-   [ ] [Design a Movie Ticket Booking System](https://www.educative.io/courses/grokking-the-object-oriented-design-interview/gxkvNgMqDk3)
-   [ ] [Design an ATM](https://www.educative.io/courses/grokking-the-object-oriented-design-interview/m22LWKgQ4Wr)
-   [ ] [Design an Airline Management System](https://www.educative.io/courses/grokking-the-object-oriented-design-interview/RMjqP6Vw98R)
-   [ ] [Design Blackjack and a Deck of Cards](https://www.educative.io/courses/grokking-the-object-oriented-design-interview/YQ5gm2APRnp)
-   [ ] [Design a Hotel Management System](https://www.educative.io/courses/grokking-the-object-oriented-design-interview/39Ek39vZBy9)
-   [ ] [Design a Restaurant Management system](https://www.educative.io/courses/grokking-the-object-oriented-design-interview/xV8p1GA6K0r)
-   [ ] [Design Chess](https://www.educative.io/courses/grokking-the-object-oriented-design-interview/JP7BXYkj3DK)
-   [ ] [Design an Online Stock Brokerage System](https://www.educative.io/courses/grokking-the-object-oriented-design-interview/RM8ol3m2o3w)
-   [ ] [Design a Car Rental System](https://www.educative.io/courses/grokking-the-object-oriented-design-interview/B8QoxDl6YON)
-   [ ] [Design LinkedIn](https://www.educative.io/courses/grokking-the-object-oriented-design-interview/gxMOMDVKlBk)
-   [ ] [Design Cricinfo](https://www.educative.io/courses/grokking-the-object-oriented-design-interview/YQ7lDLlNl5A)
-   [ ] [Design Facebook - a social network](https://www.educative.io/courses/grokking-the-object-oriented-design-interview/7n94JNyPOMw)




<u>From https://en.wikipedia.org/wiki/Design_Patterns:</u>

### Creational[[edit](https://en.wikipedia.org/w/index.php?title=Design_Patterns&action=edit&section=12)]

Main article: [Creational pattern](https://en.wikipedia.org/wiki/Creational_pattern)

[Creational patterns](https://en.wikipedia.org/wiki/Creational_pattern) are ones that create objects, rather than having to instantiate objects directly. This gives the program more flexibility in deciding which objects need to be created for a given case⁄

-   [x] [Abstract factory](https://en.wikipedia.org/wiki/Abstract_factory_pattern) groups object factories that have a common theme.
-   [x] [Builder](https://en.wikipedia.org/wiki/Builder_pattern) constructs complex objects by separating construction and representation.
-   [x] [Factory method](https://en.wikipedia.org/wiki/Factory_method_pattern) creates objects without specifying the exact class to create.
-   [x] [Prototype](https://en.wikipedia.org/wiki/Prototype_pattern) creates objects by cloning an existing object.
-   [x] [Singleton](https://en.wikipedia.org/wiki/Singleton_pattern) restricts object creation for a class to only one instance.

### Structural[[edit](https://en.wikipedia.org/w/index.php?title=Design_Patterns&action=edit&section=13)]

These concern class and object composition. They use inheritance to compose interfaces and define ways to compose objects to obtain new functionality.

-   [x] [Adapter](https://en.wikipedia.org/wiki/Adapter_pattern) allows classes with incompatible interfaces to work together by wrapping its own interface around that of an already existing class.
-   [x] [Bridge](https://en.wikipedia.org/wiki/Bridge_pattern) decouples an abstraction from its implementation so that the two can vary independently.
-   [x] [Composite](https://en.wikipedia.org/wiki/Composite_pattern) composes zero-or-more similar objects so that they can be manipulated as one object.
-   [ ] [Decorator](https://en.wikipedia.org/wiki/Decorator_pattern) dynamically adds/overrides behaviour in an existing method of an object.
-   [x] [Facade](https://en.wikipedia.org/wiki/Facade_pattern) provides a simplified interface to a large body of code.
-   [x] [Flyweight](https://en.wikipedia.org/wiki/Flyweight_pattern) reduces the cost of creating and manipulating a large number of similar objects.
-   [x] [Proxy](https://en.wikipedia.org/wiki/Proxy_pattern) provides a placeholder for another object to control access, reduce cost, and reduce complexity.

### Behavioral[[edit](https://en.wikipedia.org/w/index.php?title=Design_Patterns&action=edit&section=14)]

Most of these design patterns are specifically concerned with communication between **objects**.

-   [x] [Chain of responsibility](https://en.wikipedia.org/wiki/Chain-of-responsibility_pattern) delegates commands to a chain of processing objects.
-   [x] [Command](https://en.wikipedia.org/wiki/Command_pattern) creates objects which encapsulate actions and parameters.
-   [x] [Interpreter](https://en.wikipedia.org/wiki/Interpreter_pattern) implements a specialized language.
-   [x] [Iterator](https://en.wikipedia.org/wiki/Iterator_pattern) accesses the elements of an object sequentially without exposing its underlying representation.
-   [ ] [Mediator](https://en.wikipedia.org/wiki/Mediator_pattern) allows [loose coupling](https://en.wikipedia.org/wiki/Loose_coupling) between classes by being the only class that has detailed knowledge of their methods.
-   [ ] [Memento](https://en.wikipedia.org/wiki/Memento_pattern) provides the ability to restore an object to its previous state (undo).
-   [x] [Observer](https://en.wikipedia.org/wiki/Observer_pattern) is a publish/subscribe pattern which allows a number of observer objects to see an event.
-   [ ] [State](https://en.wikipedia.org/wiki/State_pattern) allows an object to alter its behavior when its internal state changes.
-   [x] [Strategy](https://en.wikipedia.org/wiki/Strategy_pattern) allows one of a family of algorithms to be selected on-the-fly at runtime.
-   [ ] [Template method](https://en.wikipedia.org/wiki/Template_method_pattern) defines the skeleton of an algorithm as an abstract class, allowing its subclasses to provide concrete behavior.
-   [ ] [Visitor](https://en.wikipedia.org/wiki/Visitor_pattern) separates an algorithm from an object structure by moving the hierarchy of methods into one object.
------

## Mixins vs Abstract Classes vs Interfaces

From https://stackoverflow.com/a/59752820/6463555:

  1. Abstract Class

     - Class that needs to contain one or more abstract methods

     - Abstract Class can contain state (instance variables) and non-abstract methods

  2. Interface

     - Interface contains abstract methods only (no non-abstract methods and no internal state)
  3. MixIns

     - MixIns (like Interfaces) do not contain internal state (instance variables)  
     - MixIns contain one or more non-abstract methods (they can contain non-abstract methods unlike interfaces)  
     - In e.g. Python these are just conventions, because all of the above are defined as classes. However, the common feature of both Abstract Classes, Interfaces and MixIns is that they should not exist on their own, i.e. should not be instantiated.

## Mixins in Python

Basically read **https://stackoverflow.com/questions/533631/what-is-a-mixin-and-why-are-they-useful**.  

Mixins in Python are similar to **Curiously Recurring Template Pattern (CRTP)** in C++.

From https://stackoverflow.com/a/17491186/6463555: 

> My understanding of the conventions that govern something you would call a Mixin are that a Mixin:
>
> - adds methods but not instance variables (class constants are OK)
> - only inherits from object (in Python)

**From https://stackoverflow.com/a/36222493/6463555:**

> In the context of Python especially, a mixin is a parent class that provides functionality to 
> subclasses but is not intended to be instantiated itself.

**Example of Multiple Inheritance**

This example, from the documentation, is an OrderedCounter:

```
class OrderedCounter(Counter, OrderedDict):
     'Counter that remembers the order elements are first encountered'

     def __repr__(self):
         return '%s(%r)' % (self.__class__.__name__, OrderedDict(self))

     def __reduce__(self):
         return self.__class__, (OrderedDict(self),)
```

> It subclasses both the Counter and the OrderedDict from the collections module.

> Both Counter and OrderedDict are intended to be instantiated and used on their own. However, by subclassing them both, we can have a counter that is ordered and reuses the code in each object.

> This is a powerful way to reuse code, but it can also be problematic. If it turns out there's a bug in one of the objects, fixing it without care could create a bug in the subclass.

**Example of a Mixin**  

> Unlike the example above, a mixin is not intended to be used on its own. It provides new or different functionality.
>
> For example, the standard library has a couple of mixins in the socketserver library.
>
> Forking and threading versions of each type of server can be created using these mix-in classes. For instance, ThreadingUDPServer is created as follows:

```python
class ThreadingUDPServer(ThreadingMixIn, UDPServer):
    pass
```

> The mix-in class comes first, since it overrides a method defined in UDPServer. Setting the various attributes also changes the behavior of the underlying server mechanism.
>
> In this case, the mixin methods override the methods in the UDPServer object definition to allow for concurrency.

## Metaclasses

Must read: https://stackoverflow.com/a/6581949/6463555  

> `type` is the metaclass Python uses to create all classes behind the scenes.

> You can call it a 'class factory' if you wish.

> The main purpose of a metaclass is to change the class automatically, when it's created.
> 
> You usually do this for APIs, where you want to create classes matching the current context.
>   
> Imagine a stupid example, where you decide that all classes in your module should have their attributes written in uppercase. There are several ways to do this, but one way is to set __metaclass__ at the module level.
>   
> This way, all classes of this module will be created using this metaclass, and we just have to tell the metaclass to turn all attributes to uppercase.  
>
> you can have metaclasses, inheriting from metaclasses

Why would you use metaclasses classes instead of functions?
-  Subclasses of a class will be instances of its metaclass if you specified a metaclass-class, but not with a metaclass-function.
- You can hook on __new__, __init__ and __call__. Which will allow you to do different stuff. Even if usually you can do it all in __new__, some people are just more comfortable using __init__.
-  Other reasons in the answer.

**Use of metaclasses in DJango ORM:**  
The main use case for a metaclass is creating an API. A typical example of this is the Django ORM. It allows you to define something like this:

```python
class Person(models.Model):
    name = models.CharField(max_length=30)
    age = models.IntegerField()
But if you do this:

person = Person(name='bob', age='35')
print(person.age)
```
It won't return an IntegerField object. It will return an int, and can even take it directly from the database.

This is possible because models.Model defines \_\_metaclass__ and it uses some magic that will turn the Person you just defined with simple statements into a complex hook to a database field.

Django makes something complex look simple by exposing a simple API and using metaclasses, recreating code from this API to do the real job behind the scenes.

------

From https://www.python-course.eu/python3_metaclasses.php

A metaclass is a class whose instances are classes.

Uses:
- logging and profiling
- interface checking
- registering classes at creation time
- automatically adding new methods
- automatic property creation
- proxies
- automatic resource locking/synchronization.

### Singleton using metaclasses

The singleton pattern is a design pattern that restricts the instantiation of a class to one object. It is used in cases where exactly one object is needed. The conceptcan be generalized to restrict the instantiation to a certain or fixed number of objects. The term stems from mathematics, where a singleton, - also called a unit set -, is used for sets with exactly one element.

```python
class Singleton(type):
    _instances = {}
    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)
        return cls._instances[cls]
        
class SingletonClass(metaclass=Singleton):
    pass

class RegularClass():
    pass

x = SingletonClass()
y = SingletonClass()
print(x == y) # True

x = RegularClass()
y = RegularClass()
print(x == y) # False
```
### Singleton classes using inheriting

```python
class Singleton(object):
    _instance = None
    def __new__(cls, *args, **kwargs):
        if not cls._instance:
            cls._instance = object.__new__(cls, *args, **kwargs)
        return cls._instance

class SingletonClass(Singleton):
    pass

class RegularClass():
    pass

x = SingletonClass()
y = SingletonClass()
print(x == y) # True


x = RegularClass()
y = RegularClass()
print(x == y) # False
```
### Profiling class methods using metaclasses

Counting number of call of all the functions/methods of a class.

```python
class FuncCallCounter(type):
    """ A Metaclass which decorates all the methods of the 
        subclass using call_counter as the decorator
    """
    @staticmethod
    def call_counter(func):
        """ Decorator for counting the number of function 
            or method calls to the function or method func
        """
        def helper(*args, **kwargs):
            helper.calls += 1
            return func(*args, **kwargs)
        helper.calls = 0
        helper.__name__= func.__name__
    
        return helper
    
    def __new__(cls, clsname, superclasses, attributedict):
        """ Every method gets decorated with the decorator call_counter,
            which will do the actual call counting
        """
        for attr in attributedict:
            if callable(attributedict[attr]) and not attr.startswith("__"):
                attributedict[attr] = cls.call_counter(attributedict[attr])
        
        return type.__new__(cls, clsname, superclasses, attributedict)
    
class A(metaclass=FuncCallCounter):
    
    def foo(self):
        pass
    
    def bar(self):
        pass

if __name__ == "__main__":
    x = A()
    print(x.foo.calls, x.bar.calls)
    x.foo()
    print(x.foo.calls, x.bar.calls)
    x.foo()
    x.bar()
    print(x.foo.calls, x.bar.calls)
```
OUTPUT:

```python
0 0
1 0
2 1
```

## Abstract Classes

From https://www.python-course.eu/python3_abstract_classes.php:

>   Abstract classes are classes that contain one or more abstract methods. An abstract method is a 
>   method that is declared, but contains no implementation. Abstract classes cannot be instantiated, 
>   and require subclasses to provide implementations for the abstract methods.

>   A class that is derived from an abstract class cannot be instantiated unless all of its abstract methods are overridden.

A class which inherits from an abstract class and implements all the abstractmethods is called a 
**concrete class**.

From https://stackoverflow.com/a/18030001/6463555:
> If a subclass of an abstract class overrides, i.e. provides an implementation of every abstract method in its superclass, the subclass is called a concrete class and objects of the subclass can be created
> If a subclass of an abstract class does not override (implement) all of the abstract methods it inherits, that subclass itself is also abstract and must be declared as such

```python
from abc import ABC, abstractmethod
 
class AbstractClassExample(ABC):
 
    def __init__(self, value):
        self.value = value
        super().__init__()
    
    @abstractmethod
    def do_something(self):
        pass
        
class DoAdd42(AbstractClassExample):

    def do_something(self):
        return self.value + 42
    
class DoMul42(AbstractClassExample):
   
    def do_something(self):
        return self.value * 42
    
x = DoAdd42(10)
y = DoMul42(10)

print(x.do_something())
print(y.do_something())
```
```python
52
420
```

## Interfaces in Python

Checkout **Interfaces in Other Languages** section in  https://realpython.com/python-interface.

- Python uses abstract base classes to implement interfaces.
- C++ uses **virtual** keyword before class methods to define abstract base classes.
- Java has **interface** keywork to define interfaces. **Concrete classes** use **implements** keyword to implement the interfaces.

## Factory Pattern

- https://medium.com/@hardikpatel_6314/design-patterns-in-python-factory-c728b88603eb
- From https://refactoring.guru/design-patterns/factory-method
- https://www.geeksforgeeks.org/design-patterns-set-2-factory-method/?ref=lbp

## Abstract Factory Pattern

-
https://www.geeksforgeeks.org/abstract-factory-pattern/  
https://refactoring.guru/design-patterns/abstract-factory

### Factory vs Abstract factory

- https://dzone.com/articles/factory-method-vs-abstract

- When we need another layer of abstraction.

### E.G. 1: abstract_factory.py

From https://refactoring.guru/design-patterns/abstract-factory:

> Imagine that you’re creating a furniture shop simulator. Your code consists of classes that represent:
> - A family of related products, say: Chair + Sofa + CoffeeTable.
> - Several variants of this family. For example, products Chair + Sofa + CoffeeTable are available in these variants: Modern, Victorian, ArtDeco.

### E.G. 2: abstract_factory2.py - Seems to be a better design than abstract_factory.py

From https://www.geeksforgeeks.org/abstract-factory-pattern/:

> Let’s take an example, Suppose we want to build a global car factory. If it was factory design pattern, then it was suitable for a single location. But for this pattern, we need multiple locations and some critical design changes.
> 
> We need car factories in each location like IndiaCarFactory, USACarFactory and DefaultCarFactory. Now, our application should be smart enough to identify the location where it is being used, so we should be able to use appropriate car
factory without even knowing which car factory implementation will be used internally. This also saves us from someone calling wrong factory for a particular location.
> 
> Here we need another layer of abstraction which will identify the location and internally use correct car factory implementation without even giving a single hint to user. This is exactly the problem, which abstract factory pattern is used to solve.
Somewhat the above example is also based on How the Cabs like uber and ola functions on the large scale.

### How to implement abstract factory 

From https://refactoring.guru/design-patterns/abstract-factory:

1. Map out a matrix of distinct product types versus variants of these products.

1. Declare abstract product interfaces for all product types. Then make all concrete product classes implement these interfaces.

1. Declare the abstract factory interface with a set of creation methods for all abstract products.

1. Implement a set of concrete factory classes, one for each product variant.

1. Create factory initialization code somewhere in the app. It should instantiate one of the concrete factory classes, depending on the application configuration or the current environment. Pass this factory object to all classes that construct products.

1. Scan through the code and find all direct calls to product constructors. Replace them with calls to the appropriate creation method on the factory object.

## Observer Pattern 

**see observer.py**  

From https://www.geeksforgeeks.org/observer-pattern-set-1-introduction/?ref=lbp:
> The Observer Pattern defines a one to many dependency between objects so that one object changes state, all of its dependents are notified and updated automatically.

Take care of the [**Lapsed listener problem**](https://en.wikipedia.org/wiki/Lapsed_listener_problem) by using **weak references**.

**Real Life Uses:**

- It is heavily used in GUI toolkits and event listener. In java the button(subject) and onClickListener(observer) are modelled with observer pattern.
- Social media, RSS feeds, email subscription in which you have the option to follow or subscribe and you receive latest notification.
- All users of an app on play store gets notified if there is an update.

**Good read: https://refactoring.guru/design-patterns/observer**

## Singleton

Example use cases:

- Logger
- DB connection

**Naïve** Singleton in C++: https://refactoring.guru/design-patterns/singleton/cpp/example  
**Thread-safe** Singleton in C++: https://refactoring.guru/design-patterns/singleton/cpp/example#example-1

**Thread-safe** Singleton in Python: https://refactoring.guru/design-patterns/singleton/python/example#example-1--main-py

## Strategy Pattern

From https://www.geeksforgeeks.org/strategy-pattern-set-1/

> Suppose we are building a game “Street Fighter”. For simplicity assume that a character may have
 four moves that is kick, punch, roll and jump. Every character has kick and punch moves, but roll
  and jump are optional. How would you model your classes?

**Inheritence: A Base class containing all moves?**  
We can define a Base **Figher** class with default implementation of kick, punch, roll and jump
 methods and override them in subclasses.  

- Not all players need all the moves. A player not needing jump will inherit jump. It can make
those moves *noop* but we would have to do it in **all** the sub classes. This is difficult to maintain. 
- All the player classes will need to override the methods for special moves.

**Interface for each move - {Kick,Punch,Jump,Roll}Interface?**  

- Each player can implement the interface for whatever move they require. E.g.,
    ```java
    interface Kick;
    interface Punch;
    interface Jump;
    interface Roll;
    
    class Chunli implements Kick, Punch, Jump, Roll; // Note: We can implement multiple interfaces in Java
    ```

- The main issue here is **code** reuse. Since there is no default implementation, each player
  who wants a move, say **JumpBehavior**, will need to repeat the code.

**Default Base class for each move?**  

We can have a default Base class instead of interfaces for each move. Each concrete class can
  then inherit the required classes.

```java
class DefaultKick;
class DefaultPunch;
class DefaultJump;
class DefaultRoll;

class Ryu(DefaultKick, DefaultPunch, DefaultJump)
class Ryu(DefaultKick, DefaultRoll)
```

However, **multiple inheritance** that is not supported in many languages due to many problems 
associated with it.

**Dynamic composition of each concrete move for creating a player** #Strategy Pattern
https://www.geeksforgeeks.org/strategy-pattern-set-2

1. Identify the family of algorithms which vary: we need multiple versions of kick, jump, etc. 
   Define interfaces for each family and implement concrete classes. 
```python
interface Kick;

TornadoKick implements Kick;
FlyingKick implements Kick;
```
1. In the context class, add a field for storing a reference to a strategy object. Provide a setter
   for replacing values of that field. The context should work with the strategy object only via the
   strategy interface. The context may define an interface which lets the strategy access its data.
```python
from abc import ABC, abstractmethod
class Fighter(ABC):
    def __init__(self, kick_behavior=None):
        self.kick_behavior = kick_behavior
    
    def kick(self):
        self.kick_behavior()
    
    @abstractmethod
    def display(self):
        pass

class Ryu(Fighter):
    def display(self):
        print(self.__class__.__name__)

ryu = Ryu(jump_behavior=TornadoKick)
ryu.kick() # executes TornadoKick

# Change behavior dynamically (algorithms are interchangeable)
ryu.kick_behavior = FlyingKick
ryu.kick() # executes FlyingKick
```
TODO: Implement this in Python
Ref: https://refactoring.guru/design-patterns/strategy

## Iterator Pattern

 https://www.youtube.com/watch?v=VKIzUuMdmag&list=PLF206E906175C7E07&index=18&t=0s

## Builder Pattern

Suppose we want to create two types of objects: **AppleIPhone** and **SamsungNote**. Both of these phones accept a large number of properties like cpu, ram, screen_size, battery, price, etc. We can create these phones in three different ways:

1. Use a long constructor:

   ```4python
   def AppleIphone:
     def __init__(cpu, ram, screen_size, battery, price):
       <SNIP>
   
   def SamsungNote:
     def __init__(cpu, ram, screen_size, battery, price):
       <SNIP>
   
   # Instantiation in client code
   my_iphone = AppleIPhone("qualcomm", "4GB", "5inch", "4000mMaH", "INR10K")
   ```

   Con:

   - **Possibility of switching arguments of same type**: This becomes clumsy in languages like Java and C++ which don't support passing keyword arguments to the constructor as the order is not apparent in such cases.

   - **Need to pass ALL parameters**:  In languages like C++/Java which don't have keyword arguments: We need to pass all the parameters. **Build Pattern is used to simulate keyword arguments in Java**. 

     From https://stackoverflow.com/a/1988035/6463555:

     >   The best Java idiom I've seem for simulating keyword arguments in constructors is the Builder pattern, described in [Effective Java 2nd Edition](http://java.sun.com/docs/books/effective/).
>
     >   The basic idea is to have a Builder class that has setters (but usually not getters) for the different constructor parameters. There's also a `build()` method. The Builder class is often a (static) nested class of the class that it's used to build. The outer class's constructor is often private.
>
     >   The end result looks something like:
>
     >   ```java
     >   public class Foo {
     >     public static class Builder {
     >       public Foo build() {
     >         return new Foo(this);
     >       }
     >   
     >       public Builder setSize(int size) {
     >         this.size = size;
     >         return this;
     >       }
     >   
     >       public Builder setColor(Color color) {
     >         this.color = color;
     >         return this;
     >       }
     >   
     >       public Builder setName(String name) {
     >         this.name = name;
     >         return this;
     >       }
     >   
     >       // you can set defaults for these here
     >       private int size;
     >       private Color color;
     >       private String name;
     >     }
     >   
     >     public static Builder builder() {
     >         return new Builder();
     >     }
     >   
     >     private Foo(Builder builder) {
     >       size = builder.size;
     >       color = builder.color;
     >       name = builder.name;
     >     }
     >   
     >     private final int size;
     >     private final Color color;
     >     private final String name;
     >   
     >     // The rest of Foo goes here...
     >   }
     >   ```
>
     >   To create an instance of Foo you then write something like:
>
     >   ```java
     >   Foo foo = Foo.builder()
     >       .setColor(red)
     >       .setName("Fred")
     >       .setSize(42)
     >       .build();
     >   ```
>
     >   The main caveats are:
>
     >   1. Setting up the pattern is pretty verbose (as you can see). Probably not worth it except for classes you plan on instantiating in many places.
     >   2. There's no compile-time checking that all of the parameters have been specified exactly once. You can add runtime checks, or you can use this only for optional parameters and make required parameters normal parameters to either Foo or the Builder's constructor. (People generally don't worry about the case where the same parameter is being set multiple times.)
>
     >   You may also want to check out [this blog post](http://rwhansen.blogspot.com/2007/07/theres-builder-pattern-that-joshua.html) (not by me).

   - The object phone can't be used unless **all** of its parts are instantiated. I.e., we can't use it unless we pass its `price`. 

2. Define setter for each parameter:
   This method creates an empty object and fills in the details later, which bypasses the constructor completely and these properties cannot be used during initialization. The client can instantiate the Phone step by step like:

   ```python
   my_iphone = AppleIPhone()
   
   my_iphone.set_cpu("qualcomm") # using a setter like Java/C++. We can directly set values in Python
   my_iphone.set_ram("4GB")
   # Use your iphone
   ```

   Pros:

   - Can use the object before instantiating all of its properties
   - Makes the setting of properties more explicit.

   Cons:

   - Synchronization from multiple threads is not guaranteed without using locks.
   
3. Unify construction of different kind of concrete classes:
    Read https://www.geeksforgeeks.org/builder-design-pattern/ - understand the role of **Director, Builder, ConcreteBuilder**
    Also a good read: https://refactoring.guru/design-patterns/builder
    TODO: understand this point in more details.

4.  From https://stackoverflow.com/a/22416342/6463555, this pattern seems to be used for:
    1.  **Build objects step by step:**
       This avoids having a constructor with a large number of parameters.

       Good summary about why builder pattern improves the construction problems : https://hermannyung.com/2017/05/28/builder-pattern-vs-constructor-vs-setter/

    2.  **Creating immutable objects.**
        You've never seen that used because most of the time, the builder pattern is used to build an immutable object.

        > But I don't see why they couldn't coexist. The builder builds an object, and you want the built object to be mutable, then it can have setters. But then, if it is mutable and has setters, why not build the object using a simple constructor, and call setters to change the state? The builder isn't really useful anymore, unless only one or two fields among many are mutable.

5.  From the comment in https://www.youtube.com/watch?v=k4EkJgY9P4c:

    > Builder Pattern vs Setters:     (My understanding from googling. Feel free to correct if you find it wrong)  There are classes without setters, called "Immutable Classes". They are used in distributed and multi-threaded programs where multiple threads can alter the states of an object. Developers use 'synchronize' to prevent this.  But a more convenient approach is to use Immutable classes so that threads can't alter the states via setters. (If states need to be altered a new object is created! This consumes memory which is a cons of Immutable Classes but its worth, compared to the state-altered-havocs)     Thus for Immutable Classes, Builder Pattern has to be used instead of setters

    ## Command Pattern

<u>Definition</u>:

The Command pattern 

-   **encapsulates** a request as an object

thereby letting you

-   **parametrize** other objects with different requests
-   **queue**, or
-   **log**

requests, and support 

-   **undoable operations**.



My interpretation:

-   Instead of invoking commands associated with an object directly, we instead create objects like partial functions in Python which encapsulate the commands. 
-   The command objects contain the object on which the commands have to be executed.
-   The command objects are saved in a class (called Invoker) to do fancy things like executing the commands in a batch or executing them on a remote host.
-   The client class a method like execute on the Invoker object to start the execution of the commands.



Command pattern has <u>4 components</u>:

1.  **Receiver**
    The Object that will receive and execute the command. In 

2.  **Invoker**
    Which will send the command to the receiver

3.  **Command Objects**
    Itself, which implements an **execute**, or action method, and **contains all required information** to execute it. These objects should be serializable.

4.  **Client**
    The application or component which is aware of the Receiver, Invoker and Commands

    

<u>Client code for a Light object and associated commands On, Off, Increase brightness, Decrease brightness.</u> (see command_light_switch.py)

```python
"""
Client code - client know about the other 3 parts - Receiver, Commands, and Invoker
Operations:
	- Client instantiates the Reciever object
	- Client instantiates the required commands by passing the Receiver object and required parameters.
	- Client passes the instantiated command objects to an Invoker instance.
	- Client asks the Invoker to execute the commands.
"""
light = Light() # Receiver

# Command objects
turn_light_on         = TurnONLight(light)
increase_brightness   = IncreaseBrightness(light, increase=2)
decrease_brightness   = DecreaseBrightness(light, decrease=2)
turn_light_off        = TurnOFFLight(light)

# Delegate calls to Invoker.
switch_board = SwitchBoard() # Invoker
switch_board.add(turn_light_on)
switch_board.add(increase_brightness)
switch_board.add(decrease_brightness)
switch_board.add(decrease_brightness)
switch_board.add(turn_light_off)
switch_board.execute()
```

From https://www.youtube.com/watch?v=7Pj5kAhVBlg:

>   -   This is a behvioural design pattern in which an object is used to represent and encapsulate all the information needed to call **a method at a later time**.
>   -   This information includes the method name, the object that owns the method and values for the method parameters.

From https://refactoring.guru/design-patterns/command, use this pattern:

1.  **Parametrize objects with operations**: This means turning the command into a stand-alone object to do things like: 
    -   pass it as a paratemer to a function
    -   provide the ability to customize commands. For e.g., a configure menu which provides users the flexibility to attach different actions. E.g., GUI Buttons, menus.

2.  To queue, schedule, parallelize or remotely execute the commands. The command objects are supposed to be serializable to achieve this.
3.  Provide reversible operations. Command objects can be put into a stack/queue to do reversible operations.

TODO: Implement [Messaging Queue using the Command Pattern](https://www.sitepoint.com/understanding-the-command-design-pattern/#:~:text=As you can see%2C the,action (i.e. a transaction).)



## Flyweight Pattern

Definition from https://en.wikipedia.org/wiki/Flyweight_pattern:

>   A flyweight is an [object](https://en.wikipedia.org/wiki/Object_(computer_science)) that minimizes [memory](https://en.wikipedia.org/wiki/Computer_memory) usage by sharing as much data as possible with other similar objects; it is a way to use objects in large numbers when a simple repeated representation would use an unacceptable amount of memory. Often some parts of the object state can be shared, and it is common practice to hold them in external [data structures](https://en.wikipedia.org/wiki/Data_structure) and pass them to the objects temporarily when they are used.

 This pattern is based on the concept of reusability. Heavy weight objects should be shared as much as possible. This is similar to the string objects in Python (interning).

From https://refactoring.guru/design-patterns/flyweight:

Read the game example. Imp points:

-   Flyweight objects are **immutable**

-   Intrictic state is the state which resides within a flyweight object and isn't changed; extrinsic state are the variables related to the object which can change. E.g., the sprite used to represent the bullet is an intrinsic state but the position of the bullet in the game is an extrinsic state.

    >   This constant data of an object is usually called the *intrinsic state*. It lives within the object; other objects can only read it, not change it. The rest of the object’s state, often altered “from the outside” by other objects, is called the *extrinsic state*.
    >
    >   The Flyweight pattern suggests that you stop storing the extrinsic state inside the object. Instead, you should pass this state to specific methods which rely on it. Only the intrinsic state stays within the object, letting you reuse it in different contexts. As a result, you’d need fewer of these objects since they only differ in the intrinsic state, which has much fewer variations than the extrinsic.

    >   A more elegant solution is to create a separate context class that would store the extrinsic state along with reference to the flyweight object.

-   Use a **Flyweight factory** to return already created objects using some key.

    >   For more convenient access to various flyweights, you can create a factory method that manages a pool of existing flyweight objects. The method accepts the intrinsic state of the desired flyweight from a client, looks for an existing flyweight object matching this state, and returns it if it was found. If not, it creates a new flyweight and adds it to the pool.
>
    >   There are several options where this method could be placed. The most obvious place is a flyweight container. Alternatively, you could create a new factory class. Or you could make the factory method static and put it inside an actual flyweight class.

## Facade Pattern

<u>Definition</u> from wikipedia:

>   a facade is an [object](https://en.wikipedia.org/wiki/Object_(computer_science)) that serves as a front-facing interface masking more complex underlying or structural code. 

From the comment in https://www.youtube.com/watch?v=K4FkHVO5iac (seems more useful than watching the video.)

>   Facade seems to be even simpler in my view. All those classes having complex relations is pretty irrelevant to the Facade pattern. The only thing important is that those classes are multiple and the client has to deal with all of them. So the Facade class combines interfaces of all needed classes into one interface. I.e. Client calls Facade.StartEngine, Facade.StopEngine, Facade.TurnLeft, Facade.TurnRight, and Facade class calls Engine.Start, Engine.Stop, Wheel.Left, Wheel.Right. It's useful for example in WCF services, when you have to expose many controllers' methods to an external client.

Good read: https://refactoring.guru/design-patterns/facade

An okay'ish eg of Facade in Python: https://github.com/Sean-Bradley/Design-Patterns-In-Python/blob/master/facade/shop_facade.py

# CRTP - Curiously recurring template pattern

From https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern:

-   Its an idiom in C++
-   Achives **compile time polymorphism** using template instantiation. Lookups from the virtual table during runtime polymorphism are slower compared to this technique.
-   You can read the wiki page to know its applications and shortcomings.

## Proxy Pattern

From https://en.wikipedia.org/wiki/Proxy_pattern:

>   A *proxy*, in its most general form, is a class functioning as an interface to something else. The proxy could interface to anything: a network connection, a large object in memory, a file, or some other resource that is expensive or impossible to duplicate. In short, a proxy is a wrapper or agent object that is being called by the client to access the real serving object behind the scenes. Use of the proxy can simply be [forwarding](https://en.wikipedia.org/wiki/Forwarding_(object-oriented_programming)) to the real object, or can provide additional logic. In the proxy, extra functionality can be provided, for example caching when operations on the real object are resource intensive, or checking preconditions before operations on the real object are invoked. **For the client, usage of a proxy object is similar to using the real object, because both implement the same interface.**



Used to control access to an object. Types from the HF book:

1.  **Remote**: access remote server; acess a diff namespace
2.  **Virtual**: controls access to a resource which is expensive to create; like **cache** or **lazy evaluation**.
3.  **Protection**: access management - **authentication**.

#### Decorator vs Proxy:

Decorator is more generic and supports chaining. Proxy doesn't do that. It just adds some additional behavior before the actual call is made.

## Composite Pattern

From https://en.wikipedia.org/wiki/Composite_pattern:

>   The composite pattern describes a group of objects that are treated the same way as a single instance of the same type of object. The intent of a composite is to "compose" objects into tree structures to represent part-whole hierarchies. Implementing the composite pattern lets clients treat individual objects and compositions uniformly.

Se https://en.wikipedia.org/wiki/Composite_pattern#/media/File:Composite_UML_class_diagram_(fixed).svg

From https://www.youtube.com/watch?v=EWDmWbJ4wRA (watch complete later...):

-   Sometime we want to treat individual objects and a composition of objects same from user's POV.
-   We make the **individual objects** (leaf) and the **composite of objects** implement the **same interface**. 

## Chain of Responsibility (CoR)

From https://refactoring.guru/design-patterns/chain-of-responsibility

<u>Definition</u>:
Chain of Responsibility is a behavioral pattern in which upon receiving a request the handler decides whether to process or pass the request to the next handler.

<u>Important points</u>:

>   The pattern suggests that you link these handlers into a chain. Each linked handler has a field for **storing a reference to the next handler** in the chain. In addition to processing a request, handlers pass the request further along the chain. The request travels along the chain until all handlers have had a chance to process it.

Applications:


